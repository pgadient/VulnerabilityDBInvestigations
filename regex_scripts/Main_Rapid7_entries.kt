package thesis

import javax.net.ssl.HttpsURLConnection
import java.io.*
import java.net.URL
import java.nio.charset.Charset
import java.util.ArrayList
import java.util.regex.Pattern

class Main_Rapid7_entries {

    private val numeratorFile = "rapid7-urls.csv"
    private val resultFile = "rapid7-entries.csv"

    private fun scrapeUrl(number: String): AnalysisResult {

        val httpsURL = "https://www.rapid7.com/db/$number"
        val ar = AnalysisResult()
        ar.rapid7Id = number

        try {
            val myurl = URL(httpsURL)
            val con = myurl.openConnection() as HttpsURLConnection
            con.setRequestProperty("User-Agent", "Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.4; en-US; rv:1.9.2.2) Gecko/20100316 Firefox/3.6.2") //comment
            val ins = con.inputStream
            val isr = InputStreamReader(ins)
            val `in` = BufferedReader(isr)
            var line: String? = null

            val pCVE = Pattern.compile(" *CVE-([0-2+][0-9+][0-9+][0-9+]-[0-9+]*)")
            val pRapid7Title = Pattern.compile(" *<title>([^\"]+)</title>")
            val pCVSSScore = Pattern.compile(" *<div class=\"cvss-breakdown__score cvss-breakdown__score--([^\"]+)\">([^\"]+)</div>")
            val pDisclosed = Pattern.compile(" *<header>Disclosed</header>")
            val pCreated = Pattern.compile(" *<header>Created</header>")
            val pModified = Pattern.compile(" *<header>Modified</header>")
            val pAdded = Pattern.compile(" *<header>Added</header>")
            val pCVSSRating = Pattern.compile("<header>Severity</header>")
            val pCVSS = Pattern.compile(" *<header>CVSS</header>")
            val pCellExtractor = Pattern.compile(" *<div class=\"table-cell\">([^\"]+)</div>")
            val pDateModel = Pattern.compile("<div class=\"table-cell\">([^\"]+)</div>")
            val pReferencesStart = Pattern.compile(" *<h4>References</h4>")
            val pSolution = Pattern.compile(" *<h4>Solution(s)</h4>")
            val pULend = Pattern.compile(" *</ul>")
            val pLIMatcher = Pattern.compile(" *<li>([^\"]+)</li>")
            val pParagraphMatcher = Pattern.compile(" *<p>([^\"]+)</p>")
            val pParagraphEnd = Pattern.compile(" +</p>")
            val pPlatform = Pattern.compile("<h4>Platform</h4>")
            val pArchitecture = Pattern.compile("<h4>Architectures</h4>")
            val pDescription = Pattern.compile("<h4>Description</h4>")
            val pRelatedVulnerabilities = Pattern.compile(" *<h4>Related Vulnerabilities</h4>")

            while ({ line = `in`.readLine(); line }() != null) {
                val mCVE = pCVE.matcher(line)
                if (mCVE.find() && ar.cveId == "") {
                    ar.cveId = "CVE-" + mCVE.group(1)
                }
                val mCVSSRating = pCVSSRating.matcher(line)
                if (mCVSSRating.find()) {
                    line = `in`.readLine()
                    val mScore = pCellExtractor.matcher(line)
                    if (mScore.find() && ar.CVSSScoreV3 == "") ar.CVSSScoreV3 = mScore.group(1)
                }
                val mCVSS = pCVSS.matcher(line)
                if (mCVSS.find()) {
                    line = `in`.readLine()
                    val mCVSSVector = pCellExtractor.matcher(line)
                    if (mCVSSVector.find() && ar.CVSSBreakdownV3 == "") ar.CVSSBreakdownV3 = mCVSSVector.group(1).substring(1, mCVSSVector.group(1).length - 2)
                }
                val mRapid7Title = pRapid7Title.matcher(line)
                if (mRapid7Title.find() && ar.title == "") ar.title = "\"${mRapid7Title.group(1)}\""
                val mCVSSScore = pCVSSScore.matcher(line)
                if (mCVSSScore.find() && ar.CVSSScoreV3 == "") ar.CVSSScoreV3 = "${mCVSSScore.group(2)} ${mCVSSScore.group(1)}"
                val mDisclosed = pDisclosed.matcher(line)
                if (mDisclosed.find()) {
                    line = `in`.readLine()
                    val mDate = pDateModel.matcher(line)
                    if (mDate.find() && ar.dateDisclosed == "") ar.dateDisclosed = mDate.group(1)
                }
                val mCreated = pCreated.matcher(line)
                if (mCreated.find()) {
                    line = `in`.readLine()
                    val mDate = pDateModel.matcher(line)
                    if (mDate.find() && ar.dateCreated == "") ar.dateCreated = mDate.group(1)
                }
                val mModified = pModified.matcher(line)
                if (mModified.find()) {
                    line = `in`.readLine()
                    val mDate = pDateModel.matcher(line)
                    if (mDate.find() && ar.dateModified == "") ar.dateModified = mDate.group(1)
                }
                val mAdded = pAdded.matcher(line)
                if (mAdded.find()) {
                    line = `in`.readLine()
                    val mDate = pDateModel.matcher(line)
                    if (mDate.find() && ar.dateAdded == "") ar.dateAdded = mDate.group(1)
                }
                val mPlatform = pPlatform.matcher(line)
                if (mPlatform.find()) {
                    line = `in`.readLine()
                    val mParagraph = pParagraphMatcher.matcher(line)
                    if (mParagraph.find() && ar.platform == "") ar.platform = mParagraph.group(1)
                }
                val mArchitecture = pArchitecture.matcher(line)
                if (mArchitecture.find()) {
                    line = `in`.readLine()
                    val mParagraph = pParagraphMatcher.matcher(line)
                    if (mParagraph.find() && ar.architecture == "") ar.architecture = "Architecture: ${mParagraph.group(1)}"
                }
                val mReferences = pReferencesStart.matcher(line)
                if (mReferences.find() && ar.reference == "") {
                    line = `in`.readLine(); line = `in`.readLine()
                    while (!pULend.matcher(line).find()) {
                        val mLITag = pLIMatcher.matcher(line)
                        if (mLITag.find()) ar.reference += "${mLITag.group(1)}, "
                        line = `in`.readLine()
                    }
                    if (!ar.reference.equals("")) ar.reference = "\"${ar.reference}\""
                }
                val mDescription = pDescription.matcher(line)
                if (mDescription.find() && ar.description == "") {
                    line = `in`.readLine()
                    while (!pParagraphEnd.matcher(line).find()) {
                        ar.description += line.toString().trim(); line = `in`.readLine()
                    }
                    if (!ar.description.equals("")) ar.description = "\"${ar.description}\""
                }
                val mSolution = pSolution.matcher(line)
                if (mSolution.find()) {
                    line = `in`.readLine(); line = `in`.readLine()
                    while (!pULend.matcher(line).find()) {
                        val mLI = pLIMatcher.matcher(line)
                        if (mLI.find()) ar.solution += "${mLI.group(1)}, "
                        line = `in`.readLine()
                    }
                    if (!ar.solution.equals("")) ar.solution = "\"${ar.solution}\""
                }
                val mRelatedVulnerabilities = pRelatedVulnerabilities.matcher(line)
                if (mRelatedVulnerabilities.find()) {
                    line = `in`.readLine(); line = `in`.readLine()
                    while (!pULend.matcher(line).find()) {
                        val mLI = pLIMatcher.matcher(line)
                        if (mLI.find()) ar.relatedVulnerabilities += "${mLI.group(1)}, "
                        line = `in`.readLine()
                    }
                    if (!ar.relatedVulnerabilities.equals("")) ar.relatedVulnerabilities = "\"${ar.relatedVulnerabilities}\""
                }
            }
            `in`.close()
        } catch (e: IOException) {
            val errorText = "Page not found"
            ar.cveId = errorText
            ar.CVSSScoreV3 = errorText
            ar.CVSSBreakdownV3 = errorText
            ar.title = errorText
            ar.description = errorText
            ar.dateDisclosed = errorText
            ar.dateCreated = errorText
            ar.dateModified = errorText
            ar.dateAdded = errorText
            ar.platform = errorText
            ar.architecture = errorText
            ar.reference = errorText
            ar.author = errorText
            ar.solution = errorText
            ar.relatedVulnerabilities = errorText
            println("Received PageNotFound error for " + ar.rapid7Id)
        }
        return ar
    }

    private fun read(): ArrayList<String> {
        val al = ArrayList<String>()
        try {
            val cveSampleContent = File(this.numeratorFile)
            val fis = FileInputStream(cveSampleContent)
            val isr = InputStreamReader(fis, Charset.forName("UTF-8"))
            val input = BufferedReader(isr)

            var line: String? = null
            while ({ line = input.readLine(); line }() != null) {
                if (line == "") al.add("-Empty-")
                else al.add(line!!)
            }
            input.close()
        } catch (e: IOException) {
            e.printStackTrace()
        }
        return al
    }

    private fun offlineResults(ar: AnalysisResult) {
        try {
            val cveResultData = File(this.resultFile)
            val fos = FileOutputStream(cveResultData, true)
            val osr = OutputStreamWriter(fos, Charset.forName("UTF-8"))
            val out = BufferedWriter(osr)
            out.write("${ar.cveId};${ar.rapid7Id};${ar.title};${ar.CVSSScoreV3};${ar.CVSSBreakdownV3};${ar.description};${ar.dateDisclosed};${ar.dateCreated};${ar.dateModified};${ar.dateAdded};${ar.reference};${ar.author};${ar.solution};${ar.relatedVulnerabilities}\n")
            out.close()
        } catch (e: IOException) {
            e.printStackTrace()
        }
    }

    companion object {

        @JvmStatic
        fun main(args: Array<String>) {
            val start = Main_Rapid7_entries()
            val al = start.read()
            for (s in al) {
                val ar = start.scrapeUrl(s)
                start.offlineResults(ar)
                println("${ar}\n Entry: $s")
            }
        }
    }
}
