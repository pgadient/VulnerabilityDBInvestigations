package thesis

import java.io.*
import java.net.URL
import java.nio.charset.Charset
import java.util.*
import java.util.regex.Pattern
import javax.net.ssl.HttpsURLConnection

class Main_SNYK_entries {

    private val numeratorFile = "snyk-urls.csv"
    private val resultFile = "snyk-entries.csv"

    private fun scrapeUrl(number: String): AnalysisResult {

        val httpsURL = "https://snyk.io/vuln/$number"
        val ar = AnalysisResult()
        ar.snykId = number

        try {
            val myurl = URL(httpsURL)
            val con = myurl.openConnection() as HttpsURLConnection
            con.setRequestProperty("User-Agent", "Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.4; en-US; rv:1.9.2.2) Gecko/20100316 Firefox/3.6.2") //comment
            val ins = con.inputStream
            val isr = InputStreamReader(ins)
            val `in` = BufferedReader(isr)
            var line: String? = null
            val pCVE = Pattern.compile("CVE-([^\"]+)\"")
            val pCWE = Pattern.compile(" *<a href=\"https://cwe.mitre.org/data/definitions/([^\"]+).html\"") //CWE-parseResult
            val pSnykTitle = Pattern.compile("<meta name=\"description\" content=\"([^\"]+).\">")
            val pSnykID = Pattern.compile("<link rel=\"canonical\" href=\"https://snyk.io/vuln/([^\"]+)\" />")
            val pCVSSScore = Pattern.compile(" *<div class=\"cvss-breakdown__score cvss-breakdown__score--([^\"]+)\">([^\"]+)</div>")
            val pCVSSBreakdown = Pattern.compile(" *<div class=\"cvss-breakdown__vector\">([^\"]+)</div>")
            val pDisclosed = Pattern.compile(" *<dt >Disclosed</dt>")
            val pPublished = Pattern.compile(" *<dt >Published</dt>")
            val pDDstart = Pattern.compile(" *<dd ")
            val pRightArrow = Pattern.compile(" *>")
            val pGenericMatcher = Pattern.compile(" *([^\"]+)")
            val pReferencesStart = Pattern.compile(" *<h2 id=\"references\">References</h2>")
            val pULstart = Pattern.compile(" *<ul>")
            val pULend = Pattern.compile("</ul>")
            val pOverview = Pattern.compile("<h2 id=\"overview\">Overview</h2>")
            val pEndWithH2 = Pattern.compile(" *</h2>$")
            val pReference = Pattern.compile("<li><p><a href=\"([^\"]+)\"([^\"]+)</a></p>")

            while ({ line = `in`.readLine(); line }() != null) {
                val mCVE = pCVE.matcher(line)
                if (mCVE.find() && ar.cveId == "") ar.cveId = "CVE-" + mCVE.group(1)
                val mCWE = pCWE.matcher(line)
                if (mCWE.find() && ar.cweId == "") ar.cweId = "CWE-" + mCWE.group(1)
                val mSnykTitle = pSnykTitle.matcher(line)
                if (mSnykTitle.find() && ar.title == "") ar.title = mSnykTitle.group(1)
                val mSnykId = pSnykID.matcher(line)
                if (mSnykId.find() && ar.snykId == "") ar.snykId = mSnykId.group(1)
                val mCVSSScore = pCVSSScore.matcher(line)
                if (mCVSSScore.find() && ar.CVSSScoreV3 == "") ar.CVSSScoreV3 = "${mCVSSScore.group(2)} ${mCVSSScore.group(1)}"
                val mCVSSBreakdown = pCVSSBreakdown.matcher(line)
                if (mCVSSBreakdown.find() && ar.CVSSBreakdownV3 == "") ar.CVSSBreakdownV3 = mCVSSBreakdown.group(1)
                val mDisclosed = pDisclosed.matcher(line)
                if (mDisclosed.find()) {
                    line = `in`.readLine()
                    val mDDstart = pDDstart.matcher(line)
                    if (mDDstart.find()) {
                        line = `in`.readLine(); line = `in`.readLine(); line = `in`.readLine()
                        val mrightArrow = pRightArrow.matcher(line)
                        if (mrightArrow.find()) {
                            line = `in`.readLine()
                            val mGenericMatcher = pGenericMatcher.matcher(line)
                            if (mGenericMatcher.find() && ar.dateAssigned == "") {
                                ar.dateAssigned = mGenericMatcher.group(1)
                            }
                        }
                    }
                }
                val mPublished = pPublished.matcher(line)
                if (mPublished.find()) {
                    line = `in`.readLine()
                    val mDDstart = pDDstart.matcher(line)
                    if (mDDstart.find()) {
                        line = `in`.readLine(); line = `in`.readLine(); line = `in`.readLine()
                        val mrightArrow = pRightArrow.matcher(line)
                        if (mrightArrow.find()) {
                            line = `in`.readLine()
                            val mGenericMatcher = pGenericMatcher.matcher(line)
                            if (mGenericMatcher.find() && ar.datePublished == "") {
                                ar.datePublished = mGenericMatcher.group(1)
                            }
                        }
                    }
                }
                val mReferencesStart = pReferencesStart.matcher(line)
                if (mReferencesStart.find() && ar.reference == "") {
                    line = `in`.readLine()
                    val mULstart = pULstart.matcher(line)
                    if (mULstart.find()) {
                        while (!pULend.matcher(line).find()) {
                            val mReference = pReference.matcher(line)
                            if (mReference.find()) ar.reference += mReference.group(1) + ", "
                            line = `in`.readLine()
                        }
                    }
                }
                val mOverviewMatcher = pOverview.matcher(line)
                if (mOverviewMatcher.find() && ar.description == "") {
                    line = `in`.readLine()
                    while (!pEndWithH2.matcher(line).find()) {
                        ar.description += line; line = `in`.readLine()
                    }
                    val mGeneric = pEndWithH2.matcher(line)
                    if (mGeneric.find()) when {
                        line.toString()?.contains("poc") -> {
                            line = `in`.readLine()
                            if (!pEndWithH2.matcher(line).find()) ar.poc = "\"${line}\""; line = `in`.readLine()
                        }
                        line.toString()?.contains("remediation") -> {
                            line = `in`.readLine()
                            if (!line.isNullOrEmpty()) ar.remediation = line as String; line = `in`.readLine()
                        }
                        line.toString()?.contains("affected-environments") -> {
                            line = `in`.readLine()
                            if (!pEndWithH2.matcher(line).find()) ar.affectedEnvironments += line; line = `in`.readLine()
                        }
                        line.toString()?.contains("details") -> {
                            line = `in`.readLine()
                            if (!pEndWithH2.matcher(line).find()) ar.details = line as String; line = `in`.readLine()
                        }
                    }
                }
            }
            `in`.close()
        } catch (e: IOException) {
            val errorText = "Page not found"
            ar.cveId = errorText
            ar.cweId = errorText
            ar.title = errorText
            ar.description = errorText
            ar.CVSSScoreV3 = errorText
            println("Received PageNotFound error for " + ar.snykId)
        }
        return ar
    }

    private fun read(): ArrayList<String> {
        val al = ArrayList<String>()
        try {
            val cveSampleContent = File(this.numeratorFile)
            val fis = FileInputStream(cveSampleContent)
            val isr = InputStreamReader(fis, Charset.forName("UTF-8"))
            val input = BufferedReader(isr)

            var line: String? = null
            while ({ line = input.readLine(); line }() != null) {
                if (line == "") al.add("-Empty-")
                else al.add(line!!)
            }
            input.close()
        } catch (e: IOException) {
            e.printStackTrace()
        }
        return al
    }

    private fun offlineResults(ar: AnalysisResult) {
        try {
            val cveResultData = File(this.resultFile)
            val fos = FileOutputStream(cveResultData, true)
            val osr = OutputStreamWriter(fos, Charset.forName("UTF-8"))
            val out = BufferedWriter(osr)

            out.write("${ar.cveId};${ar.cweId};${ar.snykId};${ar.CVSSScoreV3};${ar.CVSSBreakdownV3};${ar.title};\"${ar.description}\";${ar.dateAssigned};${ar.datePublished};${ar.poc};${ar.remediation};${ar.affectedEnvironments};${ar.details};\"${ar.reference}\"\n")
            out.close()
        } catch (e: IOException) {
            e.printStackTrace()
        }
    }

    companion object {
        @JvmStatic
        fun main(args: Array<String>) {
            val start = Main_SNYK_entries()
            val al = start.read()
            for (s in al) {
                val ar = start.scrapeUrl(s)
                start.offlineResults(ar)
                println("${ar}\n Entry: $s")
            }
        }
    }
}
