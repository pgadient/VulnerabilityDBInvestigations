package thesis

import javax.net.ssl.HttpsURLConnection
import java.io.*
import java.net.URL
import java.nio.charset.Charset
import java.util.ArrayList
import java.util.regex.Pattern

class Main_ExploitDB {

    private val numeratorFile = "numbers.csv"
    private val resultFile = "exploit-dbp.csv"

    private fun scrapeUrl(number: String): AnalysisResult {

        val httpsURL = "https://www.exploit-db.com/exploits/$number"
        val ar = AnalysisResult()
        ar.edbId = number

        try {
            val myurl = URL(httpsURL)
            val con = myurl.openConnection() as HttpsURLConnection
            con.setRequestProperty("User-Agent", "Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.4; en-US; rv:1.9.2.2) Gecko/20100316 Firefox/3.6.2") //comment
            val ins = con.inputStream
            val isr = InputStreamReader(ins)
            val `in` = BufferedReader(isr)
            var line: String? = null

            val pH4End = Pattern.compile(" *</h4>")
            val pStatsTitle = Pattern.compile(" *<h6 class=\"stats-title\">")
            val pTextLine = Pattern.compile(" *([^\"]+)")
            val pAfterHREF = Pattern.compile(" *<a href=\"([^\"]+)\">")

            val p1a = Pattern.compile(" *EDB-ID:") // preceded by: pH4End, pEmptyLine, pStatsTitle, pTextLine
            val p2a = Pattern.compile(" *CVE:") // preceded by: pH4End, pEmptyLine, pStatsTitle, pEmptyLine * 4,
            val p2Text = Pattern.compile(" *<a href=\"https://nvd.nist.gov/vuln/detail/CVE-([^\"]+)\"")
            val p3 = Pattern.compile("<meta name=\"author\" content=\"([^\"]+)\">")
            val p4 = Pattern.compile("<title>([^\"]+)</title>")
            val p5a = Pattern.compile(" *Type:") // preceded by: pH4End, pEmptyLine, pStatsTitle, pEmptyLine, pAfterHREF, text
            val p6simple = Pattern.compile(" *<a href=\"/raw/([^\"]+)\"")
            val p7a = Pattern.compile(" *Platform:") // preceded by: pH4End, pEmptyLine, pStatsTitle, pEmptyLine, pAfterHREF, text
            val p9 = Pattern.compile("<meta property=\"article:published_time\" content=\"([0-2+][0-9+][0-9+][0-9+]-[0-1+][0-9+]-[0-9+][0-9+])\" />") //date
            val p10 = Pattern.compile("<i class=\"mdi mdi-24px mdi-([^\"]+)\"") //EDB Verification
            val p11 = Pattern.compile("<a href=\"/apps/([^\"]+)\">") //app
            val p404 = Pattern.compile("<title>([^\"]+)| Exploit Database</title>\n")

            while ({ line = `in`.readLine(); line }() != null) {
                var m1 = p1a.matcher(line)
                if (m1.find()) {
                    line = `in`.readLine(); m1 = pH4End.matcher(line)
                    if (m1.find()) {
                        line = `in`.readLine(); line = `in`.readLine(); m1 = pStatsTitle.matcher(line)
                        if (m1.find()) {
                            line = `in`.readLine(); m1 = pTextLine.matcher(line)
                            if (m1.find() && ar.edbId == "") ar.edbId = m1.group(1)
                        }
                    }
                }
                var m2 = p2a.matcher(line)
                if (m2.find()) {
                    line = `in`.readLine(); m2 = pH4End.matcher(line)
                    if (m2.find()) {
                        line = `in`.readLine(); line = `in`.readLine(); m2 = pStatsTitle.matcher(line)
                        if (m2.find()) {
                            line = `in`.readLine(); line = `in`.readLine(); line = `in`.readLine(); line = `in`.readLine(); line = `in`.readLine()
                            m2 = p2Text.matcher(line)
                            if (m2.find() && ar.cveId == "") {
                                ar.cveId = m2.group(1)
                            } else ar.cveId = "N/A"
                        }
                    }
                }
                val m3 = p3.matcher(line)
                if (m3.find() && ar.author == "") ar.author = "\"${m3.group(1)}\""
                val m4 = p4.matcher(line)
                if (m4.find() && ar.title == "") ar.title = m4.group(1)
                var m5 = p5a.matcher(line)
                if (m5.find()) {
                    line = `in`.readLine(); m5 = pH4End.matcher(line)
                    if (m5.find()) {
                        line = `in`.readLine(); line = `in`.readLine(); m5 = pStatsTitle.matcher(line)
                        if (m5.find()) {
                            line = `in`.readLine(); line = `in`.readLine(); m5 = pAfterHREF.matcher(line)
                            if (m5.find()) {
                                line = `in`.readLine(); m5 = pTextLine.matcher(line)
                                if (m5.find() && ar.type == "") ar.type = m5.group(1)
                            }
                        }
                    }
                }

                val m6simple = p6simple.matcher(line)
                if (m6simple.find() && ar.raw == "") ar.raw = "https://www.exploit-db.com/apps/" + m6simple.group(1)
                var m7 = p7a.matcher(line)
                if (m7.find()) {
                    line = `in`.readLine(); m7 = pH4End.matcher(line)
                    if (m7.find()) {
                        line = `in`.readLine(); line = `in`.readLine(); m7 = pStatsTitle.matcher(line)
                        if (m7.find()) {
                            line = `in`.readLine(); line = `in`.readLine(); m7 = pAfterHREF.matcher(line)
                            if (m7.find()) {
                                line = `in`.readLine(); m7 = pTextLine.matcher(line)
                                if (m7.find() && ar.platform == "") ar.platform = m7.group(1)
                            }
                        }
                    }
                }
                val m9 = p9.matcher(line)
                if (m9.find() && ar.datePublished == "") ar.datePublished = m9.group(1)
                val m10 = p10.matcher(line)
                if (m10.find() && ar.edbVerification == "") {
                    ar.edbVerification = m10.group(1)
                    if (ar.edbVerification.equals("check")) ar.edbVerification = "EDB Verified"
                    if (ar.edbVerification.equals("close")) ar.edbVerification = "Not Verified"
                }
                val m11 = p11.matcher(line)
                if (m11.find() && ar.app == "") ar.app = "https://www.exploit-db.com/apps/" + m11.group(1)

                val m404 = p404.matcher(line)
                if (m404.find() && ar.title == "") ar.title = m404.group(1)

            }
            `in`.close()
        } catch (e: IOException) {
            val errorText = "Page not found"
            ar.cveId = errorText
            ar.author = errorText
            ar.type = errorText
            ar.platform = errorText
            ar.datePublished = errorText
            ar.edbVerification = errorText
            ar.app = errorText
            ar.raw = errorText
            println("Received PageNotFound error for " + ar.edbId)
        }
        return ar
    }

    private fun read(): ArrayList<String> {
        val al = ArrayList<String>()
        try {
            val cveSampleContent = File(this.numeratorFile)
            val fis = FileInputStream(cveSampleContent)
            val isr = InputStreamReader(fis, Charset.forName("UTF-8"))
            val input = BufferedReader(isr)

            var line: String? = null
            while ({ line = input.readLine(); line }() != null) {
                if (line == "") al.add("-Empty-")
                else al.add(line!!)
            }
            input.close()
        } catch (e: IOException) {
            e.printStackTrace()
        }
        return al
    }

    private fun offlineResults(ar: AnalysisResult) {
        try {
            val cveResultData = File(this.resultFile)
            val fos = FileOutputStream(cveResultData, true)
            val osr = OutputStreamWriter(fos, Charset.forName("UTF-8"))
            val out = BufferedWriter(osr)

            out.write("CVE-${ar.cveId};EDB-${ar.edbId};${ar.datePublished};\"${ar.title}\";${ar.author};${ar.type};${ar.platform};${ar.edbVerification};${ar.raw};${ar.app}\n")
            out.close()
        } catch (e: IOException) {
            e.printStackTrace()
        }
    }

    companion object {

        @JvmStatic
        fun main(args: Array<String>) {
            val start = Main_ExploitDB()
            val al = start.read()
            for (s in al) {
                val ar = start.scrapeUrl(s)
                start.offlineResults(ar)
                println("${ar}\n Entry: $s")
            }
        }
    }
}
