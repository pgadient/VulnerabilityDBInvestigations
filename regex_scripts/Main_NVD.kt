package thesis

import java.io.*
import java.nio.charset.Charset
import java.util.regex.Pattern

class Main_NVD {

    private val resultFile = "NVD-entries.csv"

    private fun scrapeUrl(inputFile: String): AnalysisResult {
        val ar = AnalysisResult()
        try {
            val nvdcveFile = File(inputFile)
            val fis = FileInputStream(nvdcveFile)
            val isr = InputStreamReader(fis)
            val `in` = BufferedReader(isr)

            val cveResultData = File(this.resultFile)
            val fos = FileOutputStream(cveResultData, true)
            val osr = OutputStreamWriter(fos, Charset.forName("UTF-8"))
            val out = BufferedWriter(osr)

            var line: String? = null
            val pCVE_Meta = Pattern.compile("\"CVE_data_meta\" : *")
            val pCVE_ID = Pattern.compile("\"ID\" : \"([^\"]+)\",")
            val pCVE_Assigner = Pattern.compile("\"ASSIGNER\" : \"([^\"]+)\"")
            val pReference = Pattern.compile("\"references\" :")
            val pVectorString = Pattern.compile("\"vectorString\" : \"([^\"]+)\",")
            val pBaseMetricV3Identifier = Pattern.compile(" *\"baseMetricV3\" : *")
            val pBaseMetricV2Identifier = Pattern.compile(" *\"baseMetricV2\" : *")
            val pPublishedDate = Pattern.compile("\"publishedDate\" : \"([^\"]+)T.*")
            val pLastModifiedDate = Pattern.compile("\"lastModifiedDate\" : \"([^\"]+)T.*")
            val pURL = Pattern.compile("\"url\" : \"([^\"]+)\",")
            val pEnd = Pattern.compile(" *} ]")
            val pEndBracket = Pattern.compile(" *},")
            val pProblemtypeData = Pattern.compile(" *\"problemtype_data\" : .*")
            val pBaseScoreV3 = Pattern.compile(" *\"baseScore\" : ([^\"]+),")
            val pBaseScoreV2 = Pattern.compile(" *\"baseScore\" : ([^\"]+)")
            val pDescriptionData = Pattern.compile("\"description\" : *")
            val pDescriptionValue = Pattern.compile("\"value\" : \"([^\']+).\"")
            val pCWE = Pattern.compile("\"value\" : \"([^\"]+)\"")
            val pStartMatcher = Pattern.compile("\"cve\" : *")

            while ({ line = `in`.readLine(); line }() != null) {
                if (pStartMatcher.matcher(line).find()) {
                    out.write("${ar.cveId};${ar.cweId};${ar.assigner};${ar.CVSSBreakdownV3};${ar.CVSSScoreV3};${ar.CVSSBreakdownV2};${ar.CVSSScoreV2};${ar.description};${ar.datePublished};${ar.dateModified};\"${ar.reference}\"\n")
                    ar.reference = ""
                    System.out.println(ar.cveId)
                    line = `in`.readLine()
                }
                val mMeta = pCVE_Meta.matcher(line)
                if (mMeta.find()) {
                    line = `in`.readLine()
                    val mID = pCVE_ID.matcher(line)
                    if (mID.find()) ar.cveId = mID.group(1); line = `in`.readLine()
                    val mAssigner = pCVE_Assigner.matcher(line)
                    if (mAssigner.find()) ar.assigner = mAssigner.group(1); line = `in`.readLine()
                }
                val mProblemTypeData = pProblemtypeData.matcher(line)
                if (mProblemTypeData.find()) {
                    line = `in`.readLine()
                    while (!pEnd.matcher(line).find()) {
                        val mCWE = pCWE.matcher(line)
                        if (mCWE.find()) ar.cweId = mCWE.group(1)
                        line = `in`.readLine()
                    }
                }

                val mDescriptionData = pDescriptionData.matcher(line)
                if (mDescriptionData.find()) {
                    line = `in`.readLine(); line = `in`.readLine(); line = `in`.readLine()
                    val mDescription = pDescriptionValue.matcher(line)
                    if (mDescription.find()) ar.description = "\"${mDescription.group(1).trim()}.\""
                }
                val mReference = pReference.matcher(line)
                if (mReference.find()) {
                    line = `in`.readLine()
                    while (!pEnd.matcher(line).find()) {
                        val mURL = pURL.matcher(line)
                        if (mURL.find()) ar.reference += "${mURL.group(1)}, "
                        line = `in`.readLine()
                    }
                    if (!ar.reference.equals("")) ar.reference = ar.reference.substring(0, ar.reference.length - 3)
                }
                val mBaseMetricV3 = pBaseMetricV3Identifier.matcher(line)
                if (mBaseMetricV3.find()) {
                    line = `in`.readLine()
                    while (!pEndBracket.matcher(line).find()) {
                        val mCVSSBreakdown = pVectorString.matcher(line)
                        if (mCVSSBreakdown.find()) ar.CVSSBreakdownV3 = mCVSSBreakdown.group(1)
                        val mCVSSScoreV3 = pBaseScoreV3.matcher(line)
                        if (mCVSSScoreV3.find()) ar.CVSSScoreV3 = mCVSSScoreV3.group(1)
                        line = `in`.readLine()
                    }
                }

                val mBaseMetricV2 = pBaseMetricV2Identifier.matcher(line)
                if (mBaseMetricV2.find()) {
                    line = `in`.readLine()
                    while (!pEndBracket.matcher(line).find()) {
                        val mCVSSBreakdown = pVectorString.matcher(line)
                        if (mCVSSBreakdown.find()) ar.CVSSBreakdownV2 = mCVSSBreakdown.group(1)
                        val mCVSSScoreV2 = pBaseScoreV2.matcher(line)
                        if (mCVSSScoreV2.find()) ar.CVSSScoreV2 = mCVSSScoreV2.group(1)
                        line = `in`.readLine()
                    }
                }
                val mPublishedDate = pPublishedDate.matcher(line)
                if (mPublishedDate.find()) ar.datePublished = mPublishedDate.group(1)
                val mLastModifiedDate = pLastModifiedDate.matcher(line)
                if (mLastModifiedDate.find()) ar.dateModified = mLastModifiedDate.group(1)
            }
            `in`.close()
            out.close()
        } catch (e: IOException) {
            val errorText = "NVDPAGE_INEXISTENT"
            ar.description = errorText
            ar.datePublished = errorText
            ar.cveId = errorText
            ar.cve = errorText
            ar.reference = errorText
            ar.assigningCNA = errorText
            ar.dateAssigned = errorText
            println("Received PageNotFound error " + ar.nvdID)
        }
        println(ar); return ar
    }


    private fun offlineResults() {
        try {
            val cveResultData = File(this.resultFile)
            val fos = FileOutputStream(cveResultData, true)
            val osr = OutputStreamWriter(fos, Charset.forName("UTF-8"))
            val out = BufferedWriter(osr)
            out.close()
        } catch (e: IOException) {
            e.printStackTrace()
        }
    }

    companion object {

        @JvmStatic
        fun main(args: Array<String>) {
            val start = Main_NVD()
            var i = 1
            var inputFile: String
            while (i in 1..19) {
                if (i < 10) inputFile = "nvdcve-1.1-200$i.json"
                else inputFile = "nvdcve-1.1-20$i.json"
                start.scrapeUrl(inputFile)
                start.offlineResults()
                i++
            }

        }
    }
}
